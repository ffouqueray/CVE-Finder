import sys, os, datetime, asyncio, json, subprocess
directory = os.path.join(os.path.dirname(__file__))
sys.path.append(directory)
from cvedetails.cve import *
from nistwebsite.nist import *

print("""
+===========================================================+
|      _______    ________   _______           __           |
|     / ____/ |  / / ____/  / ____(_)___  ____/ /__  _____  |
|    / /    | | / / __/    / /_  / / __ \/ __  / _ \/ ___/  |
|   / /___  | |/ / /___   / __/ / / / / / /_/ /  __/ /      |
|   \____/  |___/_____/  /_/   /_/_/ /_/\__,_/\___/_/       |
|                                                           |
+===========================================================+
""")
print("""
Bonjour !
Bienvenue sur le script de recherche de CVE de :
- Amine LACHGAR (@Marokingu)
- Alexi LOREAUX (@alexilrx)
- Flavien FOUQUERAY (@ffouqueray)
""")

def start(): # Proposition à l'utilisateur de taper la recherche qu'il souhaite
    choix = None
    while choix is None :
        try :
            choix = int(input("""
Quel type de recherche souhaitez vous effectuer ?
1. Recherche par vendeur /
   Produit (avec ou sans la version) /
   Numéro de CVE
   (choix de la date disponible ensuite)
2. Recherche par date par période de 120 jours max ou par année
   (recherche globale sur toutes les CVE sorties dans cette période)
3. Quitter
Votre choix : """))
            if choix not in [1, 2, 3]:
                raise Exception
        except:
            print("\nVous n'avez pas donné un nombre dans l'intervale 1-3.\nMerci de réessayer.")
            choix = None
    return choix

def SearchType(): # Si l'utilisateur choisit de faire une recherche spécifique
    choix = None
    while choix is None :
        choix = input("\nEntrez votre recherche : ")
        try:
            result = CVEFetch(choix) # On fait une requete sur le site de CVEdetails, qui nous renvoie jusqu'à 10 résultats
            if result == []:
                raise Exception
        except :
            print("\nVotre recherche n'a retourné aucun résultat.\nMerci de réessayer.\n")
            choix = None
    
    if len(result) > 1 : # Si plusieurs résultats sont retournés, on fait choisir à l'utilisateur ce qu'il demande
        print("\nQuel est le résultat exacte de votre recherche ?")
        for x in range(len(result)):
            print(f"{x+1}. {result[x]['value']}")
        
        choix = None
        while choix is None :
            try:
                choix = int(input("Votre choix : "))
                if choix < 1 or choix > len(result):
                    raise Exception
            except:
                print(f"\nVous n'avez pas donné un nombre dans l'intervale 1-{len(result)}.\nMerci de réessayer.")
                choix = None
    
    else : # Sinon on déclare choix à 1 pour récupérer le 1er résultat dans le JSON de la requete
        choix = 1
    
    categorie = result[choix-1]['category']
    value = result[choix-1]['value']
    id = result[choix-1]['id']

    # Si l'utilisateur veut utiliser des dates pour un résultat + précis (pas dispo pour les CVE).
    if categorie == "CVEs" :
        debut, fin = None, None

    else :
        choix = None
        while choix is None :
            try:
                choix = int(input("\nSouhaitez-vous approfondir la recherche avec des dates ?\n1. Oui\n2. Non\nVotre choix : "))
                if choix not in [1,2] :
                    raise Exception
            except:
                print(f"\nVous n'avez pas donné un nombre dans l'intervale 1-2.\nMerci de réessayer.")
                choix = None
        
        if choix == 1 : # S'il veut, on lance le programme
            debut, fin = ChooseDate()

        else : # Sinon on met des None pour le savoir
            debut, fin = None, None
    
    return categorie, value, id, debut, fin

def ChooseDate(): # Si l'utilisateur fait une recherche par date / ajoute une recherche par date
    choix = None
    while choix is None : # On demande a l'utilisateur s'il veut chercher avec un filtre par année ou par période de temps
        try:
            choix = int(input("\nSouhaitez-vous effectuer une recherche sur une période (120j max) ou sur une année ?\n1. Période de temps\n2. Année\nVotre choix : "))
            if choix not in [1,2] :
                raise Exception
        except:
            print(f"\nVous n'avez pas donné un nombre dans l'intervale 1-2.\nMerci de réessayer.")
            choix = None
    
    if choix == 1 : # S'il veut par période de temps, alors on boucle jusqu'à ce que les 2 dates soient à 120j max d'écart
        debut = None
        fin = None
        while (debut is None) and (fin is None) :
            try:
                while debut is None :
                    try:
                        debut = input("\nEntrez votre date de début au format suivant jj/mm/aaaa : ")
                        debut = datetime.datetime.strptime(debut, "%d/%m/%Y")
                    except:
                        print(f"\nVous n'avez pas donné une date de début au format jj/mm/aaaa.\nMerci de réessayer.")
                        debut = None

                while fin is None :
                    try:
                        fin = input("Entrez votre date de fin au format suivant jj/mm/aaaa : ")
                        fin = datetime.datetime.strptime(fin, "%d/%m/%Y")
                    except:
                        print(f"\nVous n'avez pas donné une date de fin au format jj/mm/aaaa.\nMerci de réessayer.")
                        fin = None
                periode = fin - debut
                if periode.days > 120 :
                    raise Exception
            except :
                print(f"\nLes dates sont trop décalées. Le compte fait au total {periode.days} jours, alors que le maximum est 120 jours.\nMerci de réessayer.")
                debut = None
                fin = None
    
    else : # Sinon on lui demande juste une année et on initialise la fin avec la même chose
        debut = None
        while debut is None :
            try:
                debut = input("\nEntrez votre année au format suivant AAAA : ")
                debut = datetime.datetime.strptime(debut, "%Y")
            except:
                print(f"\nVous n'avez pas donné une année au format AAAA.\nMerci de réessayer.")
                debut = None
        
        fin = debut
    
    return debut, fin

def ChoixOutput(CVEs):
    choix = None
    while choix is None : # On demande a l'utilisateur s'il veut chercher avec un filtre par année ou par période de temps
        try:
            choix = int(input("\nDans quel format de fichier souhaitez-vous effectuer l'export des données.\n1. JSON\n2. TXT\n3. Les deux\nVotre choix : "))
            if choix not in [1,2,3] :
                raise Exception
        except:
            print(f"\nVous n'avez pas donné un nombre dans l'intervale 1-3.\nMerci de réessayer.")
            choix = None
        
    filename = input(f"\nComment souhaitez-vous nommer {'votre fichier' if choix in [1,2] else 'vos fichiers'} ?\nVotre choix : ")
    filename = filename.split('.')[0]

    def CreateDirectory():
        if os.name == 'nt':
            subprocess.Popen(f'mkdir output', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).communicate()
        else :
            subprocess.Popen(f'mkdir -p output', shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL).communicate()

    def JSONFormat(CVEs, filename):
        CreateDirectory()
        with open(f'output/{filename}.json', 'w+', encoding="utf-8") as f :
            json.dump(CVEs, f, indent=4)
            f.truncate()
            f.close()
        return

    def TXTFormat(CVEs, filename):
        CreateDirectory()
        with open(f'output/{filename}.txt', 'w+', encoding="utf-8") as f :
            txtfile = ""
            for x in range(len(CVEs)):
                txtfile += f"name : {CVEs[x]['name']}\n"
                txtfile += f"link : {CVEs[x]['link']}\n"
                txtfile += f"description : {CVEs[x]['description']}\n"
                
                if type(CVEs[x]['CVSS score']) is str:
                    txtfile += f"CVSS score : {CVEs[x]['CVSS score']}\n"
                else :
                    txtfile += f"CVSS score : \n"
                    for y in range(len(CVEs[x]["CVSS score"])):
                        txtfile += f'- {list(CVEs[x]["CVSS score"])[y]} : {list(CVEs[x]["CVSS score"].values())[y]}\n'
                
                txtfile += f"published : {CVEs[x]['published']}\n"

                if 'updated' in CVEs[x] :
                    txtfile += f'updated : {CVEs[x]["updated"]}\n'
                
                txtfile += '\n'
            
            f.write(txtfile)
            f.close()
        return

    if choix == 1 :
        JSONFormat(CVEs, filename)
    
    elif choix == 2 :
        TXTFormat(CVEs, filename)
    
    else :
        JSONFormat(CVEs, filename)
        TXTFormat(CVEs, filename)
    
    return


def programme():
    ALancer = None
    while ALancer != 3 :
        ALancer = start()
        # Déclaration de toutes les variables pour scraper le bon site web
        if ALancer == 1 :
            categorie, value, id, debut, fin = SearchType() # Déclaration du type de recherche
        elif ALancer == 2 :
            categorie, value, id = None, None, None
            debut, fin = ChooseDate() # Choix des dates pour la recherche

        # On scrape le bon site web en fonction de ce qu'à sélectionné l'utilisateur
        if ALancer != 3 :
            if (debut is None) or (debut != fin) :
                CVEs = NISTscrap(categorie, value, debut, fin)
            else :
                CVEs = CVEDetailsScrap(categorie, id, debut)
        if ALancer != 3 :
            if CVEs is None :
                print("\nVotre recherche n'a retourné aucunes vulnérabilités sur la période de temps donnée.")
            else :
                ChoixOutput(CVEs)

programme()